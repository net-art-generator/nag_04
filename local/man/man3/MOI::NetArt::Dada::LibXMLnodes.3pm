.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MOI::NetArt::Dada::LibXMLnodes 3"
.TH MOI::NetArt::Dada::LibXMLnodes 3 "2003-06-29" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
MOI::NetArt::Dada::LibXMLnodes \- DaDaing LibXML Nodes ... 
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use MOI::NetArt::Dada::LibXMLnodes;
.Ve
.PP
.Vb 5
\&  my $dada = MOI::NetArt::Dada::LibXMLnodes->new(
\&                  max_stack_out_size  => 7,
\&                  max_nodes_out       => 777,
\&                  debug  => 0,
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module can be used to dada LibXML-nodes in a Markov way. 
Search for 'Markov\-Chains', if you wan't more to know.
.PP
Adding various document nodes to a nodebase. The nodes will be mapped to the
parent nodenaqme and the nodename. In this namemap every of this nodename-pairs
will be counted.
.PP
Then if the nodes are already feeded, you can query a document from this pool
of nodes.
The counter of the namemap will be decremented for each returned pair, so the 
umber of nodes is limited to the nodebase ...
You can query the nodebase node by node, or you can query a whole dada of 
LibXMLnodes.
.SH "METHODS"
.IX Header "METHODS"
.Sh "new( [option=>value ...])"
.IX Subsection "new( [option=>value ...])"
Creates a new instance of this class.
.PP
Example:
.PP
.Vb 1
\& my $dada = MOI::NetArt::Dada::LibXMLnodes->new();
.Ve
.IP "\fImax_stack_out_size\fR" 10
.IX Item "max_stack_out_size"
defining the maximum depth of LibXMLnodes while generating a Dada.
.Sp
default: 7
.IP "\fImax_nodes_out\fR" 10
.IX Item "max_nodes_out"
defining the maximum number of nodes for generating a Dada.
.Sp
default: 777
.ie n .Sh "feed( $node )"
.el .Sh "feed( \f(CW$node\fP )"
.IX Subsection "feed( $node )"
feeds the LibXML\-\f(CW$node\fR (reference) to the nodemap. Returns the nodename.
.PP
Document nodes will not be feeded to the nodebase. Please feed the
\&\f(CW$doc\fR\->\fIdocumentElement()\fR instead.
.ie n .Sh "get_node( [ $b4 ] )"
.el .Sh "get_node( [ \f(CW$b4\fP ] )"
.IX Subsection "get_node( [ $b4 ] )"
returns a node wich is mapped after the node with the name \f(CW$b4\fR. 
If \f(CW$b4\fR is not set the last returned nodename is used. If no one
returned before, then the name is a empty string.
.PP
The pair \*(L"parentname \- nodename\*(R" will be decremented in the node map.
.ie n .Sh "give_dada( [ $nw ] )"
.el .Sh "give_dada( [ \f(CW$nw\fP ] )"
.IX Subsection "give_dada( [ $nw ] )"
returns a comlete DocumentObjectModel wich is mapped after the nodename 
\&\f(CW$nw\fR. If \f(CW$nw\fR is not set 'XML::LibXML::Document' is used; \- this 
means the dada starts at the document root node.
.PP
The resulted nodename-pairs are decremented/removed in the wordmap.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MOI::Base
.SH "AUTHOR"
.IX Header "AUTHOR"
Richard Leopold, <moi\-perl@leo.0n3.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2003 by Richard Leopold
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 
